opt_out_usage
default_platform :ios

platform :ios do

  desc 'Run unit tests'
  lane :test do
    run_tests(scheme: 'Tests', output_label: 'tests')
  end

  private_lane :run_tests do |options|
    scheme = options[:scheme]
    output_label = options[:output_label]

    UI.user_error!("No Xcode scheme provided") unless scheme
    UI.user_error!("No label for the output was provided") unless output_label

    system('pkill', '-9', '-x', 'Simulator')
    UI.success('Simulator app killed')

    log_directory = "build/logs/#{output_label}"
    output_directory = "build/#{output_label}"
    ENV['XCPRETTY_JSON_FILE_OUTPUT'] = "#{output_directory}/summary.json"

    scan(
      :scheme => scheme,
      :derived_data_path => 'build/DerivedData',
      :output_directory => output_directory,
      :buildlog_path => log_directory,
      :code_coverage => true,
      :fail_build => false,
      :formatter => 'xcpretty-json-formatter'
    )

    trainer(
      path: 'build',
      output_directory: output_directory,
      extension: '.junit'
    )
  end

  desc 'Build the example app'
  lane :example do
    # Using the xcodebuild manually instead of the fastlane built in function, because this way I can manually set custom build settings, which disable code signing
    sh 'cd .. && set -o pipefail && xcodebuild build -parallelizeTargets -scheme "iOS-Example" -workspace "Example/Funky.xcworkspace" -configuration "Release" -derivedDataPath "build/DerivedData" ONLY_ACTIVE_ARCH=NO CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO | tee "build/logs/example/xcodebuild.log" | xcpretty --color --formatter `xcpretty-json-formatter`'
  end

  desc 'Lint the source code and other linteable artifacts'
  lane :lint do
    pod_lib_lint(allow_warnings: true)
  end

  desc 'Validate changes according to a set of rules'
  lane :validation do
    danger
  end

  desc 'Update the framework documentation and publish it'
  lane :update_docs do
    if git_branch == "master"
      sh 'rake docs:generate'
      sh 'rake docs:publish'
    end
  end

  desc 'Report test coverage'
  private_lane :report_coverage do
    codecov() if ENV['CODECOV_TOKEN'] or ENV['TRAVIS'] == 'true'
  end

  desc 'Continous integration'
  desc 'This action can be configured using the following environment variable (valid values are `YES` and `NO`):'
  desc ''
  desc '- `LINT`:              Whether the sources and certain artifacts should be linted defaults to `YES`'
  desc '- `RUN_TESTS`:         Whether unit tests should be run, defaults to `YES`'
  desc '- `BUILD_EXAMPLE_APP`: Whether the example app should be built or not, defaults to `YES`'
  lane :ci do
    lint if shouldPerformStep('LINT')
    test if shouldPerformStep('RUN_TESTS')
    example if shouldPerformStep('BUILD_EXAMPLE_APP')
    report_coverage if shouldPerformStep('RUN_TESTS')
    validation if shouldPerformStep('RUN_DANGER')
    update_docs if shouldPerformStep('UPDATE_DOCUMENTATION')
  end

  desc 'Pull requests'
  lane :pr do
    validation
    lint
    test
    report_coverage
    example
  end

  # Whether we should execute the step or not.
  # Looks up the value in the environment variables where a missing, empty, or 'YES' string is
  # considerered to denote that the step should be ran. Any other value is interpreted as 'skip
  # this step'.
  def shouldPerformStep(step)
    value = ENV[step].to_s.downcase

    # We should perform if the value is the empty string, or if it's set to `yes`, `true` or `1`
    value.empty? or value == 'yes' or value == '1' or value == 'true'
  end

end
